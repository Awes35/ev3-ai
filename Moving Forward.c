#pragma config(Sensor, S1,     bumperSens,     sensorEV3_Touch, modeEV3Bump)
#pragma config(Sensor, S2,     rightLight,     sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Sensor, S3,     leftLight,      sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Sensor, S4,     ultraSens,      sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, openLoop, driveRight, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,          clawMotor,     tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorD,          leftMotor,     tmotorEV3_Large, openLoop, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*------------------------------------------------------------------------------------------------
Things to know about Robot:
My robot uses negative rotations to move forward.
------------------------------------------------------------------------------------------------
Things to know about program:
This program is written to display some basic C syntax as well as to help you see a basic program.
You would not necessarily need to build a function to move your robot forward, but I wanted
to display a basic function.

This program moves the robot forward on a dark-ish surface until it reaches a light surface.
You may need to change the LIGHT_THRESHOLD value and the < or > signs to work with your situation.

Also keep in mind that you need to setup your motors and sensors to make this work.
Mine are named:
leftMotor
rightMotor
rightLight
leftLight
------------------------------------------------------------------------------------------------*/

const int FSPD = -30;
const int BSPD = 30;
int lastLeftLightVal = 0;
int newLeftLightVal = 0;
int lastRightLightVal = 0;
int newRightLightVal = 0;

//const int DIST_THRESHOLD = 40;

void moveRobotForward(){
		setMotorSpeed(leftMotor, FSPD);		//Set the leftMotor (motor1) to half power (50)
		setMotorSpeed(rightMotor, FSPD);  //Set the rightMotor (motor6) to half power (50)
}

void moveRobotBackward(){
	setMotorSpeed(leftMotor, BSPD);		//Set the leftMotor (motor1) to half power (50)
	setMotorSpeed(rightMotor, BSPD);  //Set the rightMotor (motor6) to half power (50)
}

void slowFwdRight(){
	// This makes it go slow right (right motor turning at 50% of left one)
	//setMotorSyncTime(leftMotor, rightMotor, 50, 1000, -25);
	setMotorSpeed(leftMotor, 0);			//Set the leftMotor (motor1) to Off
	setMotorSpeed(rightMotor, FSPD);  	//Set the rightMotor (motor6) to full power forward (100)
	//sleep(1500);											//Wait for 1 second before continuing on in the program.
}

void slowFwdLeft(){
	// This makes it go slow left (left motor turning at 50% of right one)
	//setMotorSyncTime(leftMotor, rightMotor, -50, 1000, -25);
	setMotorSpeed(leftMotor, FSPD);		//Set the leftMotor (motor1) to full power forward (100)
	setMotorSpeed(rightMotor, 0);  		//Set the rightMotor (motor6) to full power reverse (-100)
	//sleep(1500);											//Wait for 1 second before continuing on in the program.
}

//void findDarkness(){
//	int currDarkness;
//	int lastDarkness;
//}

//void slowFwd(){
//	// This makes it go straight (both get equal amount of power)
//	//resetMotorEncoder(leftMotor);
//	//resetMotorEncoder(rightMotor);

//// This makes it go straight (both get equal amount of power)
//	setMotorSyncTime(leftMotor, rightMotor, 0, 1000, -25);
//	sleep(1500);
//}

//void slowBkwd(){
//	// This makes it go straight (both get equal amount of power)
//	//resetMotorEncoder(leftMotor);
//	//resetMotorEncoder(rightMotor);
// setMotorSyncEncoder(nMotorOne, nMotorTwo, nTurnRatio, nEncoderCount, nSignedPower);
//	setMotorSyncTime(leftMotor, rightMotor, 0, 1000, 25);
//	sleep(1500);
//}

task main()
{
	//resetMotorEncoder(leftMotor);
	//resetMotorEncoder(rightMotor);

	motor[rightMotor] = 127;
	motor[leftMotor] = 127;

	//int n = 0;
	//while(n < 10000){
	//	moveRobotForward();
	//	n = n+ 1;
	//}

	//slowFwdRight();
	//sleep(2000);
	//slowFwdLeft();

	lastLeftLightVal = SensorValue[leftLight];
	lastRightLightVal = SensorValue[rightLight];

	moveRobotForward();

	while (true){
		newRightLightVal = SensorValue[rightLight];
		newLeftLightVal = SensorValue[leftLight];

		if (newRightLightVal == newLeftLightVal){
			if (newLeftLightVal < lastLeftLightVal){
				lastLeftLightVal = newLeftLightVal;
				lastRightLightVal = newRightLightVal;
				moveRobotForward();
			}
			else if ((newLeftLightVal > lastLeftLightVal) || (newLeftLightVal > lastRightLightVal)){
				moveRobotBackward();
				break;
			}
		}

		else if (newLeftLightVal < newRightLightVal){
			if (newLeftLightVal < lastLeftLightVal){
				lastLeftLightVal = newLeftLightVal;
				lastRightLightVal = newRightLightVal;
				slowFwdLeft();
			}
			else if (newLeftLightVal > lastLeftLightVal){
				lastLeftLightVal = newLeftLightVal;
				lastRightLightVal = newRightLightVal;
				moveRobotBackward();
				break;
			}
		}

		else if (newRightLightVal < newLeftLightVal){
			if (newRightLightVal < lastRightLightVal){
				lastLeftLightVal = newLeftLightVal;
				lastRightLightVal = newRightLightVal;
				slowFwdRight();
			}
			else if (newRightLightVal > lastRightLightVal){
				lastLeftLightVal = newLeftLightVal;
				lastRightLightVal = newRightLightVal;
				moveRobotBackward();
				break;
			}
		}

	}


    last =
    move(forward)
    //
    last < new (move back)
    if (right < left) (turn right)
    if (left < right) (turn left)
    (new < last) move fwd
    else: done
    //
//    while (true){
    front = getSensVal
    back = getSensVal
    bumper = getSensVal
    
    while (front == back){
        moveFwd()
        front = getSensVal
        back = getSensVal
        bumper = getSensVal
        
        if (bumper>0){
            moveBack()
            break
        }
    }
    //seen darkness once now
    while(true){
        if (bumper>0) -- moveBackwd & stop
        
        if (front < back) -- move fwd
        else if: (back < front) -- move backwd
        else if (back == front)
            while((front == back) && (count< 360/degree)){
                spinRight(degree)
                front = getSensVal
                back = getSensVal
                count += degree
            }
        else: done -- (back = front) and no other turn paths (at dark spot)
    }
    //
    while{
          new =
          dir = findDarknessDirection
        
          while (not eq) (dir!=done) {
              dir = findDarknessDirection //returns which way to move
              move(dir)
              
          }
    }
    
    findDarknessDirection(){
        
        if ()
            
        moveDirection = FWD
        
    }
	//sleep(2000);
	//int k = 0;
	//while(k < 10000){
	//	moveRobotBackward();
	//	k = k+ 1;
	//}

	//displayVariableValues(1,SensorValue[ultraSens]);
	//displayVariableValues(2,SensorValue[rightLight]);
}
