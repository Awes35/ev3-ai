#pragma config(Sensor, S1,     bumperSens,     sensorEV3_Touch, modeEV3Bump)
#pragma config(Sensor, S2,     rightSens,      sensorEV3_Color)
#pragma config(Sensor, S3,     leftSens,       sensorEV3_Color)
#pragma config(Sensor, S4,     ultraSens,      sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, openLoop, driveRight, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,          clawMotor,     tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorD,          leftMotor,     tmotorEV3_Large, openLoop, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*------------------------------------------------------------------------------------------------
Things to know about Robot:
My robot uses negative rotations to move forward.
------------------------------------------------------------------------------------------------
Things to know about program:
This program is written to display some basic C syntax as well as to help you see a basic program.
You would not necessarily need to build a function to move your robot forward, but I wanted
to display a basic function.

This program moves the robot forward on a dark-ish surface until it reaches a light surface.
You may need to change the LIGHT_THRESHOLD value and the < or > signs to work with your situation.

Also keep in mind that you need to setup your motors and sensors to make this work.
Mine are named:
leftMotor
rightMotor
rightLight
leftLight
------------------------------------------------------------------------------------------------*/

const int FSPD = -30;
const int BSPD = 30;
const int LIGHT_THRESHOLD = 3;

int lastLeftLightVal = 0;
int newLeftLightVal = 0;
int lastRightLightVal = 0;
int newRightLightVal = 0;

bool line_follow_active = false;
bool front_bumper_active = false;

//move command values
int MOVE_STOP = 1;
int MOVE_FWD = 2;
int MOVE_BCKWD = 3;
int MOVE_LEFT_TURN = 4;
int MOVE_RIGHT_TURN = 5;
int MOVE_LEFT_ARC = 6;
int MOVE_RIGHT_ARC = 7;
int MOVE_HARD_LEFT = 8;

//init behavior commands
int line_follow_command = MOVE_STOP;
int front_bumper_command = MOVE_STOP;

//const int DIST_THRESHOLD = 40;

void moveRobotForward(){
		setMotorSpeed(leftMotor, FSPD);		//Set the leftMotor (motor1) to half power (50)
		setMotorSpeed(rightMotor, FSPD);  //Set the rightMotor (motor6) to half power (50)
}

void moveRobotBackward(){
	setMotorSpeed(leftMotor, BSPD);		//Set the leftMotor (motor1) to half power (50)
	setMotorSpeed(rightMotor, BSPD);  //Set the rightMotor (motor6) to half power (50)
}

void slowFwdRight(){
	// This makes it go slow right (right motor turning at 50% of left one)
	//setMotorSyncTime(leftMotor, rightMotor, 50, 1000, -25);
	setMotorSpeed(leftMotor, 0);			//Set the leftMotor (motor1) to Off
	setMotorSpeed(rightMotor, FSPD);  	//Set the rightMotor (motor6) to full power forward (100)
	//sleep(1500);											//Wait for 1 second before continuing on in the program.
}

void slowFwdLeft(){
	// This makes it go slow left (left motor turning at 50% of right one)
	//setMotorSyncTime(leftMotor, rightMotor, -50, 1000, -25);
	setMotorSpeed(leftMotor, FSPD);		//Set the leftMotor (motor1) to full power forward (100)
	setMotorSpeed(rightMotor, 0);  		//Set the rightMotor (motor6) to full power reverse (-100)
	//sleep(1500);											//Wait for 1 second before continuing on in the program.
}

//void findDarkness(){
//	int currDarkness;
//	int lastDarkness;
//}

//void slowFwd(){
//	// This makes it go straight (both get equal amount of power)
//	//resetMotorEncoder(leftMotor);
//	//resetMotorEncoder(rightMotor);

//This makes it go straight (both get equal amount of power)
//	setMotorSyncTime(leftMotor, rightMotor, 0, 1000, -25);
//	sleep(1500);
//}

void Move (int op){
	switch (op){
		case MOVE_STOP:
			stopAllMotors();
			break;
		case MOVE_FWD:
			setMotorSyncTime(leftMotor, rightMotor, 0, 1000, FSPD);
			break;
		case MOVE_BCKWD:
			setMotorSyncTime(leftMotor, rightMotor, 0, 1000, BSPD);
			break;
		case MOVE_LEFT_TURN:
			setMotorSyncEncoder(leftMotor, rightMotor, -100, 175, FSPD);
			break;
		case MOVE_RIGHT_TURN:
			setMotorSyncEncoder(leftMotor, rightMotor, 100, 175, FSPD);
			break;
		case MOVE_LEFT_ARC:
			setMotorSyncTime(leftMotor, rightMotor, -30, 500, FSPD);
			break;
		case MOVE_RIGHT_ARC:
			setMotorSyncTime(leftMotor, rightMotor, 30, 500, FSPD);
			break;
		case MOVE_HARD_LEFT:
			setMotorSyncTime(leftMotor, rightMotor, 0, 400, BSPD);
			setMotorSyncEncoder(leftMotor, rightMotor, -100, 175, FSPD);
			break;
		default:
			stopAllMotors();

	}
	sleep (500);

}


task bumper_hit(){
    releaseCPU();
}


task line_follow(){ //brighter = higher val
    int rightSensVal, leftSensVal;
    int lastRightSensVal, lastLeftSensVal;
    
    lastRightSensVal = SensorValue[rightSens];
    lastLeftSensVal = SensorValue[leftSens];
    Move(MOVE_FWD);
    
    while (true){
        rightSensVal = SensorValue[rightSens];
        leftSensVal = SensorValue[leftSens];
        
//        // if Right brighter than Left
//        //right = 20, left = 14, thresh=3
//        if ((rightSensVal - leftSensVal - LIGHT_THRESHOLD) > 0){
//            line_follow_active = true;
//            line_follow_command = MOVE_LEFT_ARC;
//        }
//
//        // if Right dimmer than Left
//        // right = 20, left = 24, thresh=3
//        else if ((rightSensVal - leftSensVal + LIGHT_THRESHOLD) < 0){
//            line_follow_active = true;
//            line_follow_command = MOVE_RIGHT_ARC;
//        }
        
        //if sensors show same color.. follows DARK line
        if (abs(rightSensVal - leftSensVal) < LIGHT_THRESHOLD){
            line_follow_active = true;
            //if right changed significantly
            if ((abs(rightSensVal - lastRightSensVal) - LIGHT_THRESHOLD) > 0){
                line_follow_command = MOVE_RIGHT_ARC;
            }
            //if left changed significantly
            else if ((abs(leftSensVal - lastLeftSensVal) - LIGHT_THRESHOLD) > 0){
                line_follow_command = MOVE_LEFT_ARC;
            }
            
            //if neither changed (????)
            else {
                print("dumb error");
            }
        }
        //save last value
        lastRightSensVal = rightSensVal;
        lastLeftSensVal = leftSensVal;
        
        line_follow_active = false;
        releaseCPU();
    }//end while
    
}//end task


task main(){
	//set motor power levels (to full)
	motor[rightMotor] = 127;
	motor[leftMotor] = 127;
    
    int motorCommand;
    startTask(line_follow);
    
    while(true){
        motorCommand = MOVE_FWD;
        if (line_follow_active){
            motorCommand = line_follow_command;
        }
        if (bumper_active){
            motorCommand = bumper_command;
        }
        
        //execute
        Move(motorCommand);
        releaseCPU();
    }//end while

}//end task


	//displayVariableValues(1,SensorValue[ultraSens]);
	//displayVariableValues(2,SensorValue[rightLight]);
