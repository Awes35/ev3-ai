#pragma config(Sensor, S1,     bumperSens,     sensorEV3_Touch, modeEV3Bump)
#pragma config(Sensor, S2,     frontSens,      sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Sensor, S3,     backSens,       sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Sensor, S4,     ultraSens,      sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, openLoop, driveRight, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,          clawMotor,     tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorD,          leftMotor,     tmotorEV3_Large, openLoop, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



/*
* Authors: Kollen Gruizenga & John Weisbrod
* Function Name: findDarkness.c
* Function Purpose: Seek Darkness in given area
* 					This porgram will set the robot to move about the floor looking for darkness. One sensor is placed on the back and the 
*					other is placed on the front. As the robot moves about the surface, it continually checks to see if one sensor detects less
*					light than the other. If, for example, the front light sensor detects less light, then the robot will move forward, and vice versa.
*					If both sensors read equal darkness, then the robot will spin aroud, looking for a surrounding area that reads less darkness.
*					If no such darker "path" is found then the robot has found the darkest spot.
* Assignment name: Cockroach
*
* Notes: Logic of this function seemed fine but we ran into a couple of problems. 
* 1. sensors whenever changed from reflective to abmient, would unexpectedly and automatically change themselves back to reflective which was the undesired mode and produced faulty results (would jolt once and not proceed since light values were both zero) .... We talked to you in class about this, and you told us to mention it here.
* 2. Motors were having unexpected movement when told to simply go forward. one wheel would turn independently, then both would move
* 3. when in darkness, light levels would hardly change making it difficult for the robot to sense change
*/


const int FSPD = -30;     //forward speed
const int BSPD = 30;	  //backwards speed
const int LIGHT_THRESHOLD = 3; //sensor threshold for comparisons

//int variables to store values for sensors
int front, back, bumper;

//int lastLeftLightVal = 0;	//used for previous light measurement
//int newLeftLightVal = 0;	//current reading
//int lastRightLightVal = 0;	//used for previous light measuremtne
//int newRightLightVal = 0;	//current reading


void moveRobotForward(){
		setMotorSpeed(leftMotor, FSPD);		//Set the leftMotor (motor1) to half power (50)
		setMotorSpeed(rightMotor, FSPD);  //Set the rightMotor (motor6) to half power (50)
}

void moveRobotBackward(){
	setMotorSpeed(leftMotor, BSPD);		//Set the leftMotor (motor1) to half power (50)
	setMotorSpeed(rightMotor, BSPD);  //Set the rightMotor (motor6) to half power (50)
}

void slowFwdRight(){
	// This makes it go slow right (right motor turning at 50% of left one)
	//setMotorSyncTime(leftMotor, rightMotor, 50, 1000, -25);
	setMotorSpeed(leftMotor, 0);			//Set the leftMotor (motor1) to Off
	setMotorSpeed(rightMotor, FSPD);  	//Set the rightMotor (motor6) to full power forward (100)
	//sleep(1500);											//Wait for 1 second before continuing on in the program.
}

void slowFwdLeft(){
	// This makes it go slow left (left motor turning at 50% of right one)
	//setMotorSyncTime(leftMotor, rightMotor, -50, 1000, -25);
	setMotorSpeed(leftMotor, FSPD);		//Set the leftMotor (motor1) to full power forward (100)
	setMotorSpeed(rightMotor, 0);  		//Set the rightMotor (motor6) to full power reverse (-100)
	//sleep(1500);											//Wait for 1 second before continuing on in the program.
}


task main(){
	//set motor power levels
	motor[rightMotor] = 127;
	motor[leftMotor] = 127;

	//initial sensor values
	int front = SensorValue[frontSens];
  int back = SensorValue[backSens];
  int bumper = SensorValue[bumperSens];

  //move forward until see first darker spot (avoid spinning to check all sensors between each move)
  while (abs(front - back) < LIGHT_THRESHOLD){ //while front == back
  	moveRobotForward();
		front = SensorValue[frontSens];
  	back = SensorValue[backSens];
  	bumper = SensorValue[bumperSens];
    //if bumper is pressed
    if (bumper<1){
        moveRobotBackward();
        break;
    }
  }

  //seen darkness once now.. move to darkest spot nearby
  while(true){
  	front = SensorValue[frontSens];
  	back = SensorValue[backSens];
  	bumper = SensorValue[bumperSens];

  	//if bumper is pressed, back up and stop
    if (bumper<1){
    	moveRobotBackward();
    	break;
    }

    //code to move towards darkness
      //if front is darker than back
    if ((back - front) > LIGHT_THRESHOLD){
        //sees darkness in front, move fwd
    	moveRobotForward();
    }
      //if back is darker than front
    else if ((front - back) > LIGHT_THRESHOLD){
        //sees darkness behind, move backwd
    	moveRobotBackward();
    }
      // if both sensors are equal, do a 360 spin to find some darkness
    else if (abs(front - back) > LIGHT_THRESHOLD) {
    	int count = 0;
    	int degree = 90;
        //check surroundings (spin N times depending on "degree")
      while((front == back) && (count < 360)){
          //spin degrees to right
      	setMotorTarget(rightMotor, degree, -20);
      	waitUntilMotorStop(rightMotor);
          //get new values of sensors
        front = SensorValue[frontSens];
        back = SensorValue[backSens];
          //add to count to determine when to stop spin/checking
        count += degree;
        }
    }
    else{ //done -- (back = front) and no other turn paths (at dark spot)
    	break;
    }
  }
}
